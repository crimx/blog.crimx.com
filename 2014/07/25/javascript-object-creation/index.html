<!doctype html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="zh-cmn-Hans">
<!--<![endif]-->

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0">
<title>JavaScript 创建对象总结 | CRIMX</title>
<link rel="apple-touch-icon" sizes="57x57" href="/images/favicon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192" href="/images/favicon/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/images/favicon/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/images/favicon/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
<link rel="alternate" href="atom.xml" title="CRIMX" type="application/atom+xml">
<meta name="description" content="JavaScript 是一门灵活的语言，就创建对象而言就有各种各样的方法。本文是《JavaScript高级程序设计》（第3版）的笔记，主要是针对各种创建对象方法之间的关系、优缺点进行梳理。每种方法相关的其它细节不是本文重点，我会标记页码。

  创建单个对象
1、object 构造函数：调用 Object 的构造函数。person 的 constructor 值是 Object。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 创建对象总结">
<meta property="og:url" content="https://blog.crimx.com/2014/07/25/javascript-object-creation/index.html">
<meta property="og:site_name" content="CRIMX">
<meta property="og:description" content="JavaScript 是一门灵活的语言，就创建对象而言就有各种各样的方法。本文是《JavaScript高级程序设计》（第3版）的笔记，主要是针对各种创建对象方法之间的关系、优缺点进行梳理。每种方法相关的其它细节不是本文重点，我会标记页码。

  创建单个对象
1、object 构造函数：调用 Object 的构造函数。person 的 constructor 值是 Object。">
<meta property="og:image" content="https://blog.crimx.com/images/post/javascript/object-prototype.png">
<meta property="og:updated_time" content="2016-12-29T10:38:32.939Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 创建对象总结">
<meta name="twitter:description" content="JavaScript 是一门灵活的语言，就创建对象而言就有各种各样的方法。本文是《JavaScript高级程序设计》（第3版）的笔记，主要是针对各种创建对象方法之间的关系、优缺点进行梳理。每种方法相关的其它细节不是本文重点，我会标记页码。

  创建单个对象
1、object 构造函数：调用 Object 的构造函数。person 的 constructor 值是 Object。">
<meta name="twitter:image" content="https://blog.crimx.com/images/post/javascript/object-prototype.png">
<meta name="twitter:creator" content="@straybugs">
<link rel="stylesheet" href="/static/style.css">
<!-- <script src="js/vendor/modernizr-2.8.3-respond-1.4.2.min.js"></script> -->
<script>
! function() {
    var e = document.getElementsByTagName("html")[0];
    e.className = (" " + e.className + " ").replace(" no-js ", " ").slice(1, -1)
}()
</script>
</head>

<body>
<!--[if lte IE 9]>
    <p class="browser-warning" style="position:fixed;top:0;left:0;right:0;padding:10px;text-align:center;color:red;background:yellow;">Why are you still using old version of IE??? Go and <a href="http://browsehappy.com/">upgrade your browser</a>.</p>
  <![endif]-->
<div class="site-container">
<div class="site-menu js-progressive-bg-container" style="background:url(/images/cover/pexels-photo-19031-portrait.jpg) 33.69% 46.93%/cover">
<div class="site-menu-bg-thumb js-progressive-bg-thumbnail" style="background:url(data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAeABEDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAMFBgcE/8QAKRAAAQMDAQUJAAAAAAAAAAAAAgABAwQFESESEzFBUhUWIiMyM1FTYf/EABYBAQEBAAAAAAAAAAAAAAAAAAIBBP/EABsRAAMAAgMAAAAAAAAAAAAAAAABEQISEyEx/9oADAMBAAIRAxEAPwBNFergFY5SPz9KulPezkpxJh14PlZoV3i8sox8b83Xed4mGJiEm044RaoscoaN2mhZn3kqOpCmguVFIra1oQaOMsv8pVPc5GjeN5H1/VHe6Dm/HKSTbEj4dL0z1om9+X2oUHvD6kK9kp//2Q==) 33.69% 46.93%/cover"></div>
<div class="site-menu-inner-wrapper">
<div class="menu-logo">
<a class="icon-logo" href="/"></a>
</div>
<ul class="menu-social-icons">
<li>
<a class="icon-weibo" href="//www.weibo.com/straybugs" target="_blank"></a>
</li>
<li>
<a class="icon-github" href="//github.com/crimx" target="_blank"></a>
</li>
<li>
<a class="icon-mail" href="mailto:%73%74%72%61%79%62%75%67%73%40%67%6D%61%69%6C%2E%63%6F%6D" target="_blank"></a>
</li>
<li>
<a class="icon-rss" href="/atom.xml"></a>
</li>
</ul>
<ul class="menu-navs">
<li><a href="/categories/">Categories</a></li>
<li><a href="/archives/">Archives</a></li>
<li><a href="/tags/">Tags</a></li>
<li><a href="/search/">Search</a></li>
<li><a href="/about/">About</a></li>
</ul>
</div>
</div>
<div class="site-menu-mask"></div>
<div class="main-content">
<header class="site-cover js-progressive-bg-container" style="background:url(/images/cover/pexels-photo-19031-portrait.jpg) 33.69% 46.93%/cover">
<div class="site-cover-bg-thumb js-progressive-bg-thumbnail" style="background:url(data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAeABEDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAMFBgcE/8QAKRAAAQMDAQUJAAAAAAAAAAAAAgABAwQFESESEzFBUhUWIiMyM1FTYf/EABYBAQEBAAAAAAAAAAAAAAAAAAIBBP/EABsRAAMAAgMAAAAAAAAAAAAAAAABEQISEyEx/9oADAMBAAIRAxEAPwBNFergFY5SPz9KulPezkpxJh14PlZoV3i8sox8b83Xed4mGJiEm044RaoscoaN2mhZn3kqOpCmguVFIra1oQaOMsv8pVPc5GjeN5H1/VHe6Dm/HKSTbEj4dL0z1om9+X2oUHvD6kK9kp//2Q==) 33.69% 46.93%/cover"></div>
<a class="cover-logo" href="/"></a>
<div class="title-wrapper">
<h1 class="site-title" itemprop="name">JavaScript 创建对象总结</h1>
<div class="article-meta">
<div class="article-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a></div><a href="/2014/07/25/javascript-object-creation/" class="article-date"><time datetime="2014-07-24T16:00:00.000Z" itemprop="datePublished">2014-07-25</time></a>
<a rel="license"
class="cc-license-wrapper" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" title="This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License."><svg class="cc-license" fill="#fff"><use xlink:href="/images/symbol-defs.svg#icon-cc-license"/></svg></a>
</div>
</div>
</header>
<div class="tagline-wrap">
<section class="tagline">
<blockquote class="tagline-content">对 JavaScript 中各种创建对象方法的总结</blockquote>
</section>
</div>
<div class="toc-mousearea"></div>
<div class="toc-wrapper">
<div class="toc-container">
<ol class="toc">
<li class="toc-item toc-level-2"><a class="toc-link" href="#创建单个对象"><span class="toc-text">创建单个对象</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数模式"><span class="toc-text">构造函数模式</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#组合使用构造函数模式和原型模式"><span class="toc-text">组合使用构造函数模式和原型模式</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#动态原型模式"><span class="toc-text">动态原型模式</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#寄生构造函数模式"><span class="toc-text">寄生构造函数模式</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#稳妥构造函数模式"><span class="toc-text">稳妥构造函数模式</span></a></li>
<li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li>
</ol>
</div>
</div>
<article id="post-javascript-object-creation" class="article--post" itemscope="" itemprop="blogPost">
<div class="article-inner js-no-wrap-menu">
<div class="article-entry" itemprop="articleBody">
<p>JavaScript 是一门灵活的语言，就创建对象而言就有各种各样的方法。本文是《JavaScript高级程序设计》（第3版）的笔记，主要是针对各种创建对象方法之间的关系、优缺点进行梳理。每种方法相关的其它细节不是本文重点，我会标记页码。</p>
<h2 id="创建单个对象">
<a href="#创建单个对象" class="headerlink" title="创建单个对象"></a>创建单个对象</h2>
<p>1、object 构造函数：调用 <code>Object</code> 的构造函数。<code>person</code> 的 <code>constructor</code> 值是 <code>Object</code>。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">'StrayBugs'</span>;</div><div class="line">person.age = <span class="number">22</span>;</div><div class="line">person.job = <span class="string">'student'</span>;</div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>2、字面量：不会调用 <code>Object</code> 的构造函数。而 <code>person</code> 的 <code>constructor</code> 值也是 <code>Object</code>。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'StrayBugs'</span>,</div><div class="line">	<span class="attr">age</span>: <span class="number">22</span>,</div><div class="line">	<span class="attr">job</span>: <span class="string">'student'</span>,</div><div class="line">	<span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>优点：简单、方便<br>缺点：批量创建对象很麻烦。不能使用 <code>instanceof</code> 来确定对象类型（都是 <code>Object</code>）。</p>
<h2 id="工厂模式">
<a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2>
<p>工厂模式是为了解决批量创建对象的问题。</p>
<p>就是用一个函数将上述创建单个对象的方法包装起来，就可以减少代码量了。以第一种方法为例：</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'StrayBugs'</span>, <span class="number">22</span>, <span class="string">'student'</span>);  </div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'Angel'</span>, <span class="number">20</span>, <span class="string">'Artist'</span>);</div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>优点：减少了代码量。<br>缺点：未能解决对象识别的问题。</p>
<h2 id="构造函数模式">
<a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2>
<p>构造函数模式解决了对象识别问题，是基于工厂模式的改进。</p>
<p>是利用了 new 作用域转移的特性。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">	<span class="keyword">this</span>.job = job;</div><div class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'StrayBugs'</span>, <span class="number">22</span>, <span class="string">'student'</span>);  </div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Angel'</span>, <span class="number">20</span>, <span class="string">'Artist'</span>);</div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>必须用 <code>new</code> 操作符来创建 <code>Person</code> 实例。以这种方式调用构造函数实际上会经历以下4个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此 <code>this</code> 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<p>此时 <code>person1</code> 与 <code>person2</code> 都可以用 <code>constructor</code> 和 <code>instanceof</code> 来验证其对象类型是 <code>Person</code>。</p>
<p>当不使用 <code>new</code> 来创建对象时，由于在全局作用域中 <code>this</code> 指向 <code>Global</code>（浏览器中就是 <code>window</code> 对象），所以可以直接通过 <code>window</code> 对象调用 <code>sayName</code>，不建议这么做，会污染全局环境。</p>
<p>也可以用 <code>call()</code> 与 <code>apply()</code> 来为 <code>Person</code> 指定作用域。</p>
<p>优点：在工厂模式的基础上解决了对象识别问题。<br>缺点：每个实例的方法都是独立的，多数情况下同个对象的实例方法都是一样的，于是这里造成了冗余。<br>偏方：将函数定义单独出来，如下面例子：</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">	<span class="keyword">this</span>.job = job;</div><div class="line">	<span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'StrayBugs'</span>, <span class="number">22</span>, <span class="string">'student'</span>);  </div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Angel'</span>, <span class="number">20</span>, <span class="string">'Artist'</span>);</div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>这么写是不是很别扭，也没有封装性可言。</p>
<h2 id="原型模式">
<a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2>
<p>原型模式很好解决了上面的封装性问题。原型也是 JavaScrip 最重要的特性之一。书本篇幅比较长，这里只为了突出原型要解决的问题，所以会省略很多。</p>
<p>原型就是为了共用而生：默认情况下，每个对象与它的所有实例都共用一个原型。对象可以通过 <code>.prototype</code> 访问原型。实例存在内部属性 <code>[[Prototype]]</code>，不能直接访问（不推荐使用 <code>__proto__</code>）。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125; </div><div class="line"> </div><div class="line">Person.prototype.name = <span class="string">'StrayBugs'</span>; </div><div class="line">Person.prototype.age = <span class="number">22</span>; </div><div class="line">Person.prototype.job = <span class="string">'student'</span>; </div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    alert(<span class="keyword">this</span>.name); </div><div class="line">&#125;; </div><div class="line"> </div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </div><div class="line">person1.sayName();   <span class="comment">//"StrayBugs" </span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName();   <span class="comment">//"StrayBugs" </span></div><div class="line"> </div><div class="line">alert(person1.sayName == person2.sayName);  <span class="comment">//true</span></div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>原型也可以用字面量来创建，但是其 <code>constructor</code> 要手动修改，具体方法及副作用见书 P155。</p>
<p>如下图，原型的 <code>constructor</code> 属性指向 <code>Person</code>，<code>Person</code> 的两个实例的 <code>[[Prototype]]</code> 直接指向原型，与 <code>Person</code> 没有直接关系。</p>
<p><img src="/images/post/javascript/object-prototype.png" alt="prototype"></p>
<p>上图可以看到三者是共用同一个原型。于是 <code>Person</code> 在原型上的改变会影响到所有的实例。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
</td>
<td class="code">
<pre><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    alert(<span class="string">"hi!"</span>); </div><div class="line">&#125;;</div><div class="line"></div><div class="line">person1.sayName();   <span class="comment">//"hi!" </span></div><div class="line">person2.sayName();   <span class="comment">//"hi!"</span></div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>注意当实例上存在与原型重名的属性时，实例的属性会屏蔽掉原型的属性。因为先是查看实例中有无该属性，没找到才会去原型中查找。书本 P150。</p>
<p>对象还可以重写原型，但此时已创建的实例依然指向旧原型（前面说了实例原型与对象无直接关系）。书本 P157</p>
<p>优点：共用原型减少了冗余。<br>缺点：在原型上的改变会影响到所有的实例，于是实例没有了独立性。</p>
<h2 id="组合使用构造函数模式和原型模式">
<a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2>
<p>目的是解决原型模式的独立性问题。将需要共用的属性（一般是方法）定义在原型上，将独立的属性定义在构造函数中。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </div><div class="line">    <span class="keyword">this</span>.name = name; </div><div class="line">    <span class="keyword">this</span>.age = age; </div><div class="line">    <span class="keyword">this</span>.job = job; </div><div class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>]; </div><div class="line">&#125; </div><div class="line"> </div><div class="line">Person.prototype = &#123; </div><div class="line">    <span class="attr">constructor</span> : Person, </div><div class="line">    <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">        alert(<span class="keyword">this</span>.name); </div><div class="line">    &#125; </div><div class="line">&#125;; </div><div class="line"> </div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'StrayBugs'</span>, <span class="number">22</span>, <span class="string">'student'</span>); </div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Angel'</span>, <span class="number">20</span>, <span class="string">'Artist'</span>); </div><div class="line"> </div><div class="line">person1.friends.push(<span class="string">"Van"</span>); </div><div class="line">alert(person1.friends);    <span class="comment">//"Shelby,Count,Van" </span></div><div class="line">alert(person2.friends);    <span class="comment">//"Shelby,Count" </span></div><div class="line">alert(person1.friends === person2.friends);    <span class="comment">//false </span></div><div class="line">alert(person1.sayName === person2.sayName);    <span class="comment">//true</span></div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>优点：结合了构造函数模式和原型模式的优点，并解决了其缺点。<br>缺点：代码没有很好的封装起来。</p>
<h2 id="动态原型模式">
<a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2>
<p>看到这里也应该猜到，动态原型模式就是为了解决上面的封装问题。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </div><div class="line"> </div><div class="line">    <span class="comment">//属性 </span></div><div class="line">    <span class="keyword">this</span>.name = name; </div><div class="line">    <span class="keyword">this</span>.age = age; </div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line"></div><div class="line">    <span class="comment">//方法 </span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123; </div><div class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">            alert(<span class="keyword">this</span>.name); </div><div class="line">        &#125;; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'StrayBugs'</span>, <span class="number">22</span>, <span class="string">'student'</span>); </div><div class="line">friend.sayName(); <span class="comment">//'StrayBugs'</span></div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>这里即使有多个方法也只需判断其中一个方法存不存在即可开始初始化。</p>
<p>到了这里其实最后两种创建对象的方法已经非常完美了。接下来讲的是一些特殊情况下，上面都不适应时的方法。</p>
<h2 id="寄生构造函数模式">
<a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2>
<p>顾名思义，有时候我们需要在一些已有的对象上添加一些方法，但是又不能（或不希望）改变该对象的构造函数，就可以用寄生构造函数模式。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> createPerson(<span class="string">'StrayBugs'</span>, <span class="number">22</span>, <span class="string">'student'</span>);  </div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> createPerson(<span class="string">'Angel'</span>, <span class="number">20</span>, <span class="string">'Artist'</span>);</div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>它的定义方法跟工厂模式一模一样，不同的是调用时使用 <code>new</code> 创建。这是因为虽然里面都是 <code>o</code>，工厂模式中的 <code>o</code> 是作为实例，所以返回的是实例。寄生构造函数模式中的 <code>o</code> 是作为构造函数，所以返回的是构造函数。下面的例子更贴切。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123; </div><div class="line"> </div><div class="line">    <span class="comment">//创建数组 </span></div><div class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(); </div><div class="line"> </div><div class="line">    <span class="comment">//添加值 </span></div><div class="line">    values.push.apply(values, <span class="built_in">arguments</span>); </div><div class="line"> </div><div class="line">    <span class="comment">//添加方法 </span></div><div class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>); </div><div class="line">    &#125;; </div><div class="line">     </div><div class="line">    <span class="comment">//返回数组 </span></div><div class="line">    <span class="keyword">return</span> values; </div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>); </div><div class="line">alert(colors.toPipedString()); <span class="comment">//"red|blue|green"</span></div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>这样就在 <code>Array</code> 的基础上建立了新的构造函数了。</p>
<p>缺点：与工厂模式一样，不能依赖 <code>instanceof</code> 操作符来确定对象类型。</p>
<h2 id="稳妥构造函数模式">
<a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2>
<p>主要是为了在安全执行环境中使用。P161</p>
<p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：<br>一是新创建对象的实例方法不引用 this；<br>二是不使用 new 操作符调用构造函数。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </div><div class="line">     </div><div class="line">    <span class="comment">//创建要返回的对象 </span></div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </div><div class="line"></div><div class="line">    <span class="comment">//可以在这里定义私有变量和函数 </span></div><div class="line"> </div><div class="line">    <span class="comment">//添加方法 </span></div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">        alert(name); </div><div class="line">    &#125;;     </div><div class="line">     </div><div class="line">    <span class="comment">//返回对象 </span></div><div class="line">    <span class="keyword">return</span> o; </div><div class="line">&#125;</div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>这里除了使用 <code>sayName()</code> 方法之外，没有其他办法访问 <code>name</code> 的值。可以像下面使用稳妥的 <code>Person</code> 构造函数。</p>
<p></p>
<figure class="highlight javascript">
<table>
<tr>
<td class="gutter">
<pre><div class="line">1</div><div class="line">2</div></pre>
</td>
<td class="code">
<pre><div class="line"><span class="keyword">var</span> friend = Person(<span class="string">'StrayBugs'</span>, <span class="number">22</span>, <span class="string">'student'</span>); </div><div class="line">friend.sayName();  <span class="comment">//'StrayBugs'</span></div></pre>
</td>
</tr>
</table>
</figure>
<p></p>
<p>缺点：与寄生构造函数一样，不能依赖 <code>instanceof</code> 操作符来确定对象类型。</p>
<h2 id="总结">
<a href="#总结" class="headerlink" title="总结"></a>总结</h2>
<p>以上五花八门的创建对象方式正体现了 JavaScript 的灵活性。这里没有好与差的方法，只有最适合的方法。我认为重点是把这几种方法串起来，因为如果不了解其 WHAT HOW WHY，不仅很容易就忘记了，而且不能清晰的了解在什么场合适合运用什么方法。所以希望有机会能看到这篇文章的同学以后不用再愁“对象问题”啦！</p>
</div>
</div>
<footer class="article-footer">
<ul class="article-tag-list">
<li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li>
<li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object/">Object</a></li>
<li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Understanding-JavaScript/">Understanding JavaScript</a></li>
</ul>
<nav id="article-nav"><a href="/2014/07/27/javascript-inheritance/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">newer</strong><div class="article-nav-title">JavaScript 继承总结</div></a>
<a href="/2014/07/23/18-surprises-from-reading-jquery-s-source-code/"
id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">older</strong>
<div class="article-nav-title">阅读 jQuery 源码的18个惊喜</div>
</a>
</nav>
</footer>
</article>
<section id="comments">
<div id="disqus_thread">
<div class="no-disqus">由于某种不可跨越的鸿沟，评论可能加载不了。</div><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank">comments powered by Disqus.</a></noscript></div>
</section>
<script>
var disqus_config = function() {
    this.page.url = "https://blog.crimx.com/2014/07/25/javascript-object-creation/", this.page.identifier = "2014/07/25/javascript-object-creation/"
};
! function() {
    var t = document,
        e = t.createElement("script");
    e.src = "//crimx.disqus.com/embed.js", e.setAttribute("data-timestamp", +new Date), (t.head || t.body).appendChild(e)
}()
</script>
<div class="menu-icon"><i class="menu-icon__logo"></i></div>
<footer class="site-footer">
<ul class="recommended-post">
<li class="recommended-post__item">
<a class="recommended-post__link" href="#">
<div class="recommended-post__cover js-progressive-bg-container">
<div class="recommended-post__thumbnail js-progressive-bg-thumbnail"></div>
</div>
<h1 class="recommended-post__title"></h1>
</a>
</li>
<li class="recommended-post__item">
<a class="recommended-post__link" href="#">
<div class="recommended-post__cover js-progressive-bg-container">
<div class="recommended-post__thumbnail js-progressive-bg-thumbnail"></div>
</div>
<h1 class="recommended-post__title"></h1>
</a>
</li>
<li class="recommended-post__item">
<a class="recommended-post__link" href="#">
<div class="recommended-post__cover js-progressive-bg-container">
<div class="recommended-post__thumbnail js-progressive-bg-thumbnail"></div>
</div>
<h1 class="recommended-post__title"></h1>
</a>
</li>
<li class="recommended-post__item">
<a class="recommended-post__link" href="#">
<div class="recommended-post__cover js-progressive-bg-container">
<div class="recommended-post__thumbnail js-progressive-bg-thumbnail"></div>
</div>
<h1 class="recommended-post__title"></h1>
</a>
</li>
</ul>
<div class="site-description">I <a href="https://github.com/crimx/" target="_blank">code</a>, <a href="http://codepen.io/straybugs/" target="_blank">design</a>, <a href="https://twitter.com/straybugs/" target="_blank">tweet</a> &amp; <a href="https://blog.crimx.com" target="_blank">blog</a>.</div>
<div
class="copyright">© COPYRIGHT 2016 · Designed &amp; Wrote With <svg class="icon-heart"><use xlink:href="/images/symbol-defs.svg#icon-heart"/></svg></div>
</footer>
</div>
</div>
<script src="/static/bundle.js"></script>
<!-- Google Analytics -->
<script type="text/javascript">
! function(e, a, t, n, c, o, s) {
    e.GoogleAnalyticsObject = c, e[c] = e[c] || function() {
        (e[c].q = e[c].q || []).push(arguments)
    }, e[c].l = 1 * new Date, o = a.createElement(t), s = a.getElementsByTagName(t)[0], o.async = 1, o.src = n, s.parentNode.insertBefore(o, s)
}(window, document, "script", "//www.google-analytics.com/analytics.js", "ga"), ga("create", "UA-49163616-1", "auto"), ga("send", "pageview")
</script>
<!-- End Google Analytics --><noscript><style>.noscript-warning{position:fixed;z-index:999999;top:0;left:0;right:0;margin:auto;padding:10px;font-size:1.2em;color:#fff;background:orange;text-align:center}</style><div class="noscript-warning">This site works best with JavaScript enabled</div></noscript></body>

</html>